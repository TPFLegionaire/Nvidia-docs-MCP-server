# App Flow Document

## Onboarding and Sign-In/Sign-Up
A developer or administrator enters the application by navigating to the server’s base URL in a browser or using an API client. They may begin on the Swagger UI page, which is accessible at the `/docs` endpoint, or they can go directly to the `/login` REST endpoint. To create an account in version 1.0, the user must already have credentials or a service account provided by an operations team, since this server uses JWT-based authentication without an open self-registration flow. Once they reach the `/login` page, they submit their username and password over HTTPS. The server validates these credentials and, on success, returns a JSON Web Token. This token is then included in the `Authorization` header of subsequent API calls. There is no visual “sign-out” button; instead, the client simply discards the token when they wish to sign out. If a token expires or is forgotten, the user must call the same `/login` endpoint again to obtain a new token. At this stage there is no in-app password recovery or reset page; credential resets are handled outside the application by an administrator.

## Main Dashboard or Home Page
After obtaining a valid JWT, the first interface a user typically sees is the Swagger UI served at `/docs`. This page lists all available REST endpoints under categories like authentication, MCP operations, and health checks. On the left side of the Swagger UI, the user finds the full API reference. On the right side, they see interactive request forms where they can expand each endpoint, fill in parameters, and execute calls directly from the browser. There is also a link at `/docs/index.html` for static project documentation. From the Swagger UI, a user can click on any REST endpoint to view request details, response schemas, and example usage. Behind the scenes, the same documentation folder can also be browsed at versioned paths such as `/docs/v1.0/` or `/docs/latest/`. Navigation from this dashboard to the health check page, to actual API calls, or to the static docs is seamless and driven by links in the header and sidebar.

## Detailed Feature Flows and Page Transitions
When a client process wants to join a communication group, it first calls the `/mcp/register` REST endpoint, supplying its unique client ID in the JSON body and attaching the JWT in the `Authorization` header. The server verifies the token, registers the client, and returns a confirmation message. Once registered, the client may use `/mcp/send` by posting a message payload and a target group ID, again including the JWT. The server enqueues the message and acknowledges receipt with a status code and message ID. On the receiving side, another client polls `/mcp/receive` with its client ID and group ID. The server returns any new messages as a JSON array. In parallel, clients built on gRPC call the `RegisterClient`, `SendMessage`, and `ReceiveMessages` RPC methods defined in the `.proto` files in the `proto/` folder. These methods mirror the REST endpoints but use HTTP/2 framing for lower latency.

Separately, when a user wants to view static documentation, they navigate from the Swagger UI or directly enter the path `/docs/index.html`. The server serves HTML and Markdown content from the configured `docs/` directory. Users can switch between versions by changing the URL path. The server respects caching headers and content-type metadata, streaming files efficiently so large documents do not block other operations.

## Settings and Account Management
There is no user-facing settings page for personal profiles in version 1.0. Instead, global application settings are managed by administrators via environment variables or a YAML configuration file. To update ports, logging levels, or documentation paths, the administrator edits the `config.yml` file or updates environment variables, then restarts the server if the dynamic reload flag is not enabled. For authentication parameters such as token expiry time, they adjust the JWT secret and expiry duration in configuration. After saving these changes, the server picks them up on a graceful restart, and normal flows resume without any impact on registered clients beyond planned downtime.

## Error States and Alternate Paths
If a client submits invalid credentials at the `/login` endpoint, the server responds with a 401 status and an error message indicating mismatched username or password. When calling any MCP endpoint without a valid token or with an expired token, the API returns a 403 error with a prompt to re-authenticate. Network connectivity issues cause gRPC streams to drop or REST calls to time out, resulting in client-side catch blocks or HTTP 504 gateway timeouts. If the server’s configuration reload fails due to invalid YAML syntax, it logs an error and continues running with the last known good configuration. For missing documentation files, a 404 page is shown with a simple message stating the file cannot be found and suggesting the user verify the doc path or version.

## Conclusion and Overall App Journey
From the moment a developer points their browser to the server’s URL or fires up an API client, they follow a clear progression: authenticate via the `/login` endpoint to receive a JWT, explore available APIs through the Swagger UI, register their process with `/mcp/register`, and exchange messages using `/mcp/send` and `/mcp/receive` or via gRPC methods. At any time they can browse static or versioned documentation through the `/docs` paths. Administrators manage server settings by editing a config file or environment variables and can restart the service to apply changes. Error responses guide both developers and processes to retry authentication, correct request payloads, or report missing resources. This flow ensures smooth onboarding, reliable inter-process communication, and quick access to up-to-date Nvidia-related documentation in a consistent, secured, and observable environment.