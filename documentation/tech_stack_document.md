# Tech Stack Document

This document explains the technology choices for the **Nvidia-docs-MCP-server** in clear, everyday language. It covers the tools and frameworks used on the frontend and backend, how we deploy and maintain the service, the external services we rely on, and the security and performance measures we’ve put in place.

## 1. Frontend Technologies
Although this project is primarily a backend service, it does expose a simple user interface for documentation and API exploration:

- **Swagger UI**
  - Automatically generated by FastAPI to let users explore and test REST endpoints in their browser.
  - Provides an interactive API reference without requiring separate frontend code.
- **Static HTML and Markdown files**
  - Stored in the `docs/` folder and served directly over HTTP(S).
  - Versioned paths (e.g., `/docs/v1.0/`, `/docs/latest/`) let you maintain multiple document releases side by side.
- **FastAPI’s StaticFiles module**
  - Built-in utility to mount and serve static content (HTML, CSS, JS, images) efficiently.

These choices keep the frontend simple and maintenance-free while giving users a clear, interactive way to read docs and exercise the APIs.

## 2. Backend Technologies
The core server handles multi-process communication (MCP) and document hosting. Here’s what makes it work:

- **Python 3.9+ with FastAPI**
  - Provides an async web framework for building REST endpoints quickly and clearly.
  - Automatic data validation, dependency injection, and OpenAPI support.
- **ASGI Server: Uvicorn or Hypercorn**
  - Runs the FastAPI application with high performance and support for asynchronous I/O.
- **gRPC support (`grpcio`, Protobuf)**
  - Defines and runs high-performance RPC methods in `proto/` files for low-latency client communication.
- **Configuration**
  - **PyYAML** reads settings from `config.yml`.
  - **python-dotenv** loads environment variables from a `.env` file.
- **Authentication & Authorization**
  - **PyJWT** issues and verifies JSON Web Tokens (JWT) for secure access.
  - FastAPI security utilities enforce role-based access (reader vs. writer).
- **Logging & Observability**
  - **structlog** or Python’s standard `logging` module outputs structured JSON logs.
  - **prometheus-client** exposes metrics (request rates, error counts) on a `/metrics` endpoint.
- **Testing**
  - **pytest** for unit and integration tests.
  - **httpx** for HTTP testing and a gRPC test client (`grpctest`).

Together, these components manage user requests, communicate between processes, and serve documentation files in a robust and scalable way.

## 3. Infrastructure and Deployment
To ensure reliable, repeatable deployments and smooth operations, we use:

- **Version Control: Git & GitHub**
  - All code and configuration are stored in a Git repository with clear commit history and branching strategy.
- **Containerization: Docker**
  - A Dockerfile defines a consistent runtime environment for Python, dependencies, and configuration.
  - Enables easy local testing and production deployments.
- **Orchestration: Docker Compose / Kubernetes**
  - **Docker Compose** for simple, single-machine setups (development, small installations).
  - **Kubernetes** for production clusters, autoscaling, and high availability.
- **CI/CD Pipelines**
  - Automated build, test, and deployment using GitHub Actions (or a similar CI system).
  - Ensures each pull request triggers checks (linting, tests) and safe rollouts.
- **Secrets & Configuration Management**
  - Environment variables or secret stores (e.g., AWS Secrets Manager) hold JWT keys and other sensitive data.
  - Config files (`config.yml`) and `.env` files let operators change settings without touching code.

These decisions make deployments repeatable, allow us to scale as demand grows, and reduce manual steps when releasing updates.

## 4. Third-Party Integrations
We rely on a few external libraries and services to deliver key features:

- **FastAPI**
  - The main web framework for REST and OpenAPI.
- **grpcio & Protobuf**
  - For gRPC-based communication with low overhead.
- **PyJWT**
  - Token-based authentication.
- **PyYAML & python-dotenv**
  - Flexible configuration loading.
- **structlog**
  - Structured, JSON-formatted logs for machine parsing.
- **prometheus-client**
  - Exporting metrics for monitoring and alerting.
- **Uvicorn / Hypercorn**
  - High-performance ASGI servers.

Each of these libraries is well-maintained and widely used, so we benefit from community support and regular security updates.

## 5. Security and Performance Considerations
To protect data and maintain responsive service, we’ve implemented:

Security Measures:
- **TLS Encryption (HTTPS)**: All HTTP endpoints are served over TLS to protect data in transit.
- **JWT Authentication**: Short-lived tokens (15-minute expiry) guard all MCP and docs endpoints.
- **Role-Based Access Control**: Separate reader and writer permissions limit what clients can do.
- **Input Validation**: FastAPI’s built-in validators prevent injection attacks and malformed requests.
- **Audit Logging**: All authentication attempts and errors are logged for forensic analysis.

Performance Optimizations:
- **Asynchronous I/O**: FastAPI + Uvicorn handle thousands of concurrent connections without blocking.
- **Worker Pooling**: Horizontal scaling behind a load balancer lets us add more replicas when load spikes.
- **In-Memory Caching**: Frequently accessed docs can be cached (HTTP cache headers) to reduce file reads.
- **Efficient File Serving**: Streaming static files to avoid loading entire documents into memory.

These measures keep the service fast, secure, and resilient under load.

## 6. Conclusion and Overall Tech Stack Summary

In summary, the **Nvidia-docs-MCP-server** combines modern, community-backed tools to deliver a secure, high-performance platform for:

- **Multi-Process Communication** (MCP) via both REST and gRPC
- **Static Documentation Hosting** with versioning and caching
- **Robust Configuration, Observability, and Security**

Key strengths of our stack:
- **FastAPI and Python 3.9+** for rapid development and async performance
- **Docker and Kubernetes** for consistent, scalable deployments
- **JWT and TLS** for end-to-end security
- **Prometheus and structlog** for deep visibility and monitoring

This combination aligns perfectly with the project’s goals—providing sub-100 ms message round-trips, sub-50 ms doc loads, and 99.9% uptime—while keeping the system maintainable and extensible for future enhancements.